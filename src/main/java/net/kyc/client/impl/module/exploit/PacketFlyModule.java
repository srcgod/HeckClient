package net.kyc.client.impl.module.exploit;

import net.minecraft.client.gui.screen.DeathScreen;
import net.minecraft.client.gui.screen.DownloadingTerrainScreen;
import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket;
import net.minecraft.network.packet.c2s.play.TeleportConfirmC2SPacket;
import net.minecraft.network.packet.s2c.play.PlayerPositionLookS2CPacket;
import net.minecraft.network.packet.s2c.play.PositionFlag;
import net.minecraft.util.math.Vec2f;
import net.minecraft.util.math.Vec3d;
import net.kyc.client.api.config.Config;
import net.kyc.client.api.config.setting.BooleanConfig;
import net.kyc.client.api.config.setting.EnumConfig;
import net.kyc.client.api.config.setting.NumberConfig;
import net.kyc.client.api.event.EventStage;
import net.kyc.client.api.event.listener.EventListener;
import net.kyc.client.api.module.ModuleCategory;
import net.kyc.client.api.module.ToggleModule;
import net.kyc.client.impl.event.ScreenOpenEvent;
import net.kyc.client.impl.event.TickEvent;
import net.kyc.client.impl.event.entity.player.PlayerMoveEvent;
import net.kyc.client.impl.event.network.DisconnectEvent;
import net.kyc.client.impl.event.network.PacketEvent;
import net.kyc.client.impl.event.network.PlayerUpdateEvent;
import net.kyc.client.impl.event.network.PushOutOfBlocksEvent;
import net.kyc.client.init.Managers;
import net.kyc.client.mixin.accessor.AccessorPlayerPositionLookS2CPacket;
import net.kyc.client.util.math.position.TimedVec3d;
import net.kyc.client.util.string.EnumFormatter;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.TimeUnit;

/**
 * @author linus, Gavin
 * @since 1.0
 */
public class PacketFlyModule extends ToggleModule {

    //
    Config<FlyMode> modeConfig = new EnumConfig<>("Mode", "The packetfly mode for spoofing packets", FlyMode.FAST, FlyMode.values());
    Config<Float> factorConfig = new NumberConfig<>("Factor", "The tick " + "factor when applying packets", 1.0f, 1.0f, 10.0f, () -> modeConfig.getValue() == FlyMode.FACTOR);
    Config<Float> reductionConfig = new NumberConfig<>("Reduction", "The reduction vertical factor", 0.0f, 0.0f, 2.5f);
    Config<Phase> phaseConfig = new EnumConfig<>("Phase", "The phase/noclip type for moving through blocks", Phase.FULL, Phase.values());
    Config<Type> typeConfig = new EnumConfig<>("Type", "The out of bounds packet type", Type.DOWN, Type.values());
    Config<Limit> limitConfig = new EnumConfig<>("Limit", "The horizontal speed limit", Limit.OFF, Limit.values());
    Config<Boolean> verticalLimitConfig = new BooleanConfig("Limit-Vertical", "Slows down when moving vertically", false);
    Config<Boolean> concealConfig = new BooleanConfig("Conceal", "Conceals the out of bounds packet", false);
    Config<Boolean> limitJitterConfig = new BooleanConfig("LimitJitter", "Prevents the jitter when flying", true);
    Config<Boolean> slowConfig = new BooleanConfig("Conceal-Slow", "Slows down the speed to the concealed speed", false);
    Config<Boolean> antiKickConfig = new BooleanConfig("AntiKick", "Prevents the vanilla anticheat from kicking for flying", true);
    //
    private int limitTicks;
    private boolean limitSpeed;
    private int antiKickTicks;
    private int teleportId;
    private boolean concealTeleportPacket;
    //
    private static final float CONCEAL_SPEED = 0.0624f;
    //
    private static final double MOVE_FACTOR = 1.0 / Math.sqrt(2.0);
    //
    private final Set<PlayerMoveC2SPacket> clientPositionPackets = new HashSet<>();
    private final ConcurrentMap<Integer, TimedVec3d> serverPositionPredictions =
            new ConcurrentHashMap<>();

    /**
     *
     */
    public PacketFlyModule() {
        super("PacketFly", "Allows player to fly by abusing 1.9+ packet exploit",
                ModuleCategory.EXPLOITS);
    }

    /**
     * @return
     */
    @Override
    public String getModuleData() {
        return EnumFormatter.formatEnum(modeConfig.getValue());
    }

    /**
     *
     */
    @Override
    public void onDisable() {
        if (mc.player == null) {
            return;
        }
        serverPositionPredictions.clear();
        teleportId = 0;
        mc.player.noClip = false;
    }

    @Override
    public void onUpdate() {

    }

    @EventListener
    public void onDisconnect(DisconnectEvent event) {
        disable();
    }

    @EventListener
    public void onScreenOpen(ScreenOpenEvent event) {
        if (event.getScreen() instanceof DeathScreen) {
            disable();
        }
    }

    @EventListener
    public void onPacketOutbound(PacketEvent.Outbound event) {
        if (event.getPacket() instanceof PlayerMoveC2SPacket packet
                && !clientPositionPackets.contains(packet) && !mc.isInSingleplayer()) {
            event.cancel();
        }
    }

    @EventListener
    public void onPacketInbound(PacketEvent.Inbound event) {
        if (mc.player == null || mc.world == null || mc.isInSingleplayer()
                || mc.currentScreen instanceof DownloadingTerrainScreen) {
            return;
        }
        if (event.getPacket() instanceof PlayerPositionLookS2CPacket packet) {
            TimedVec3d predictPos = serverPositionPredictions.remove(packet.getTeleportId());
            if (predictPos != null && predictPos.getX() == packet.getX()
                    && predictPos.getY() == packet.getY() && predictPos.getZ() == packet.getZ()) {
                if (modeConfig.getValue() != FlyMode.SETBACK) {
                    event.cancel();
                }
                Managers.NETWORK.sendPacket(new TeleportConfirmC2SPacket(packet.getTeleportId()));
                return;
            } else if (concealConfig.getValue() && predictPos != null && (predictPos.getX() != packet.getX()
                    || predictPos.getY() != packet.getY() || predictPos.getZ() != packet.getZ())) {
                concealTeleportPacket = true;
            }
            packet.getFlags().remove(PositionFlag.X_ROT);
            packet.getFlags().remove(PositionFlag.Y_ROT);
            ((AccessorPlayerPositionLookS2CPacket) packet).setYaw(mc.player.getYaw());
            ((AccessorPlayerPositionLookS2CPacket) packet).setPitch(mc.player.getPitch());
            Managers.NETWORK.sendPacket(new TeleportConfirmC2SPacket(packet.getTeleportId()));
            teleportId = packet.getTeleportId();
        }
    }

    @EventListener
    public void onPlayerUpdate(PlayerUpdateEvent event) {
        if (event.getStage() != EventStage.PRE) {
            return;
        }
        if (modeConfig.getValue() != FlyMode.SETBACK && teleportId == 0
                && !mc.isInSingleplayer()) {
            if (checkAntiKick(4)) {
                final Vec3d playerPos = mc.player.getPos();
                sendMovePacket(playerPos);
                if (concealTeleportPacket && concealConfig.getValue()) {
                    sendMovePacket(getConcealVec(playerPos));
                    concealTeleportPacket = false;
                }
                sendMovePacket(typeConfig.getValue().getOutOfBoundsVec3d(playerPos));
                if (modeConfig.getValue() != FlyMode.SETBACK) {
                    serverPositionPredictions.put(++teleportId, new TimedVec3d(playerPos, System.currentTimeMillis()));
                    if (limitJitterConfig.getValue()) {
                        Managers.NETWORK.sendPacket(new TeleportConfirmC2SPacket(teleportId));
                    }
                }
            }
            return;
        }
        final boolean blockPhased = isBlockPhased();
        float moveSpeed = slowConfig.getValue() || phaseConfig.getValue() == Phase.FULL
                && blockPhased ? 0.031f : getLimitedSpeed();
        boolean antiKick = false;
        double motionY;
        if (mc.options.jumpKey.isPressed()) {
            if (antiKickConfig.getValue() && !blockPhased) {
                antiKick = checkAntiKick(modeConfig.getValue() == FlyMode.SETBACK ? 10 : 20)
                        && mc.player.forwardSpeed == 0.0f
                        && mc.player.sidewaysSpeed == 0.0f;
                motionY = antiKick ? -0.032 : CONCEAL_SPEED;
                if (verticalLimitConfig.getValue() && (mc.player.forwardSpeed != 0.0f
                        || mc.player.sidewaysSpeed != 0.0f)) {
                    // factor = 1;
                    moveSpeed *= MOVE_FACTOR;
                    motionY *= MOVE_FACTOR;
                }
            } else {
                motionY = CONCEAL_SPEED;
                if (verticalLimitConfig.getValue() && (mc.player.forwardSpeed != 0.0f
                        || mc.player.sidewaysSpeed != 0.0f)) {
                    // factor = 1;
                    moveSpeed *= MOVE_FACTOR;
                    motionY *= MOVE_FACTOR;
                }
            }
        } else if (mc.options.sneakKey.isPressed()) {
            motionY = -CONCEAL_SPEED;
            if (verticalLimitConfig.getValue() && (mc.player.forwardSpeed != 0.0f
                    || mc.player.sidewaysSpeed != 0.0f)) {
                // factor = 1;
                moveSpeed *= MOVE_FACTOR;
                motionY *= MOVE_FACTOR;
            }
        } else {
            if (!blockPhased && antiKickConfig.getValue()) {
                antiKick = checkAntiKick(4)
                        && mc.player.forwardSpeed == 0.0f
                        && mc.player.sidewaysSpeed == 0.0f;
                motionY = antiKick ? -0.04 : 0.0;
            } else {
                motionY = 0.0;
            }
        }
        if (phaseConfig.getValue() == Phase.FULL && blockPhased && motionY != 0.0) {
            motionY /= 2.5 + reductionConfig.getValue();
        }
        //
        int i = 1;
        final Vec2f motion = handleFlightMotion(moveSpeed);
        while (i <= (modeConfig.getValue() == FlyMode.FACTOR ? factorConfig.getValue().intValue() : 1)) {
            double motionX = motion.x * i;
            double motionZ = motion.y * i;
            if (!antiKick) {
                motionY *= i;
            }
            mc.player.setVelocity(motionX, motionY, motionZ);
            if (!mc.isInSingleplayer()) {
                final Vec3d pos = mc.player.getPos();
                final Vec3d move = pos.add(motionX, motionY, motionZ);
                sendMovePacket(move);
                if (concealTeleportPacket && concealConfig.getValue()) {
                    sendMovePacket(getConcealVec(move));
                    concealTeleportPacket = false;
                }
                sendMovePacket(typeConfig.getValue().getOutOfBoundsVec3d(move));
                if (modeConfig.getValue() != FlyMode.SETBACK) {
                    serverPositionPredictions.put(++teleportId, new TimedVec3d(move, System.currentTimeMillis()));
                    Managers.NETWORK.sendPacket(new TeleportConfirmC2SPacket(teleportId));
                }
            }
            i++;
        }
    }

    @EventListener
    public void onPlayerMove(PlayerMoveEvent event) {
        if (mc.player == null) {
            return;
        }
        final Vec3d move = mc.player.getVelocity();
        event.setX(move.x);
        event.setY(move.y);
        event.setZ(move.z);
        if (phaseConfig.getValue() != Phase.OFF) {
            mc.player.noClip = true;
        }
        event.cancel();
    }

    @EventListener
    public void onTick(TickEvent event) {
        if (event.getStage() != EventStage.PRE) {
            return;
        }
        serverPositionPredictions.entrySet().removeIf(pos ->
        {
            final TimedVec3d timeVec = pos.getValue();
            long elapsed = System.currentTimeMillis() - timeVec.time();
            return elapsed > TimeUnit.SECONDS.toMillis(30L);
        });
    }

    @EventListener
    public void onPushOutOfBlocks(PushOutOfBlocksEvent event) {
        event.cancel();
    }

    private void sendMovePacket(Vec3d vec) {
        PlayerMoveC2SPacket packet = new PlayerMoveC2SPacket.PositionAndOnGround(
                vec.getX(), vec.getY(), vec.getZ(), mc.player.isOnGround());
        Managers.NETWORK.sendPacket(packet);
        clientPositionPackets.add(packet);
    }

    private Vec3d getConcealVec(Vec3d vec) {
        return new Vec3d(vec.x, RANDOM.nextDouble(278.0, 295.0) * (vec.y > 127.5 ? -1.0 : 1.0), vec.z);
    }

    private float getLimitedSpeed() {
        return switch (limitConfig.getValue()) {
            case TICK -> 0.1899f;
            case SPEED -> {
                if (!limitSpeed) {
                    if (checkLimitSpeed(7)) {
                        limitSpeed = true;
                    }
                    yield 0.253f;
                } else {
                    if (checkLimitSpeed(7)) {
                        limitSpeed = false;
                    }
                    yield 0.198f;
                }
            }
            case BOTH -> {
                if (!limitSpeed) {
                    if (checkLimitSpeed(1)) {
                        limitSpeed = true;
                    }
                    yield 0.256f;
                } else {
                    if (checkLimitSpeed(1)) {
                        limitSpeed = false;
                    }
                    yield 0.1899f;
                }
            }
            case OFF -> 0.26f;
        };
    }

    private Vec2f handleFlightMotion(float speed) {
        float forward = mc.player.input.movementForward;
        float strafe = mc.player.input.movementSideways;
        float yaw = mc.player.prevYaw + (mc.player.getYaw() - mc.player.prevYaw) * mc.getTickDelta();
        if (forward == 0.0f && strafe == 0.0f) {
            return Vec2f.ZERO;
        } else if (forward != 0.0f) {
            if (strafe >= 1.0f) {
                yaw += forward > 0.0f ? -45 : 45;
                strafe = 0.0f;
            } else if (strafe <= -1.0f) {
                yaw += forward > 0.0f ? 45 : -45;
                strafe = 0.0f;
            }
            if (forward > 0.0f) {
                forward = 1.0f;
            } else if (forward < 0.0f) {
                forward = -1.0f;
            }
        }
        float rx = (float) Math.cos(Math.toRadians(yaw));
        float rz = (float) -Math.sin(Math.toRadians(yaw));
        return new Vec2f((forward * speed * rz) + (strafe * speed * rx),
                (forward * speed * rx) - (strafe * speed * rz));
    }

    private boolean checkAntiKick(int ticks) {
        if (++antiKickTicks >= ticks) {
            antiKickTicks = 0;
            return true;
        }
        return false;
    }

    private boolean checkLimitSpeed(int ticks) {
        if (++limitTicks >= ticks) {
            limitTicks = 0;
            return true;
        }
        return false;
    }

    /**
     * Returns <tt>true</tt> if the player bounding {@link net.minecraft.util.math.Box}
     * is inside of a block.
     *
     * @return <tt>true</tt> if the player is phased
     */
    private boolean isBlockPhased() {
        return !mc.world.isSpaceEmpty(mc.player, mc.player.getBoundingBox().expand(-0.0625, -0.0625, -0.0625));
    }

    public enum FlyMode {
        FACTOR,
        FAST,
        SETBACK
    }

    public enum Phase {
        FULL,
        SEMI,
        OFF
    }

    public enum Limit {
        TICK,
        SPEED,
        BOTH,
        OFF
    }

    public enum Type {
        UP() {
            @Override
            public Vec3d getOutOfBoundsVec3d(Vec3d vec) {
                return vec.subtract(0.0, 1337.0, 0.0);
            }
        },
        DOWN() {
            @Override
            public Vec3d getOutOfBoundsVec3d(Vec3d vec) {
                return vec.add(0.0, 1337.0, 0.0);
            }
        },
        PRESERVE() {
            @Override
            public Vec3d getOutOfBoundsVec3d(Vec3d vec) {
                return vec.add(RANDOM.nextDouble(100000), 0.0, RANDOM.nextDouble(100000));
            }
        },
        PRESERVE_BOUNDED() {
            @Override
            public Vec3d getOutOfBoundsVec3d(Vec3d vec) {
                return Vec3d.ZERO;
            }
        },
        BOUNDED() {
            @Override
            public Vec3d getOutOfBoundsVec3d(Vec3d vec) {
                return new Vec3d(vec.x, -vec.y + (vec.y < 127.5 ?
                        255.0 : 0.0), vec.z);
            }
        },
        CONCEAL() {
            @Override
            public Vec3d getOutOfBoundsVec3d(Vec3d vec) {
                return vec.add(RANDOM.nextDouble(-100000, 100000), 2.0, RANDOM.nextDouble(-100000, 100000));
            }
        },
        LIMIT() {
            @Override
            public Vec3d getOutOfBoundsVec3d(Vec3d vec) {
                return vec.add(RANDOM.nextDouble(-50, 50), RANDOM.nextDouble(50, 80) *
                                (RANDOM.nextBoolean() ? 1.0 : -1.0), RANDOM.nextDouble(-50, 50));
            }
        },
        LIMIT_JITTER() {
            @Override
            public Vec3d getOutOfBoundsVec3d(Vec3d vec) {
                return vec.add(RANDOM.nextDouble(-10, 10), RANDOM.nextDouble(80, 100) *
                                (RANDOM.nextBoolean() ? 1.0 : -1.0), RANDOM.nextDouble(-10, 10));
            }
        };

        public abstract Vec3d getOutOfBoundsVec3d(Vec3d vec);
    }
}
